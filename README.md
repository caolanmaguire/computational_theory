![computational theory banner](https://github.com/caolanmaguire/calsickofthis/blob/main/COMPUTAT.png)

# Computational Foundations: A Research Project in Theoretical Computer Science

| **Researcher**       | Caolán Maguire       |
|----------------------|--------------------------|
| **Identifier**       | G00385433               |
| **Module Name/Topic**  | Computational Theory    |

## Abstract

This research project explores fundamental concepts in computational theory, examining both classical and contemporary approaches to computation. The work investigates binary representations, cryptographic hashing, prime number theory, and Turing machines to establish connections between historical computational principles and modern applications. Through practical implementations and theoretical analysis, this project contributes to the understanding of computational complexity and its implications for computer science as described by Sipser (2012) in his seminal work on the theory of computation.

## Research Objectives & Additional Explorations

This project aims to:
1. Investigate the theoretical foundations of computation through practical implementation
2. Analyze the relationship between mathematical principles and computational processes
3. Explore the evolution of computational models from historical implementations to modern AI systems
4. Examine cryptographic principles and their application in modern computing

## Historical Context

The field of computational theory has evolved significantly since its formalization in the 1930s when Alan Turing introduced his abstract computing machine, establishing the foundation for theoretical computer science (Turing, 1936). This project traces this evolution through practical implementations of key concepts.

### Key Resources & Related Work

- Computational Complexity: A Modern Approach (Arora & Barak, 2009)
- Introduction to the Theory of Computation (Sipser, 2012)
- Historical repositories on early computational models
- Video lecture series on theoretical computer science foundations

## Research Components

### Comparative Analysis: From ELIZA to ChatGPT

This section explores the evolution of natural language processing systems, analyzing the fundamental differences between early rule-based systems like ELIZA which Weizenbaum (1966) designed as a simple pattern-matching program that simulated conversation and modern transformer-based models like ChatGPT. The analysis considers architectural differences, learning approaches, and philosophical implications.

## Experimental Implementations

### Experiment 1: Binary Representations
Investigation of numerical encoding systems and their computational properties.

### Experiment 2: Hash Functions
Analysis of mapping techniques for data integrity and security applications.

### Experiment 3: SHA256
Implementation and examination of the SHA256 cryptographic hash function which was standardized by the National Institute of Standards and Technology (NIST) and remains fundamental to modern security systems (NIST, 2015).

### Experiment 4: Prime Numbers
Exploration of prime number theory and its applications in cryptography and number theory.

### Experiment 5: Mathematical Roots
Investigation of computational approaches to root-finding algorithms.

### Experiment 6: Proof of Work
Analysis of computational challenge systems used in blockchain technology and cryptocurrencies.

### Experiment 7: Turing Machines
Implementation of theoretical models of computation based on Turing's original concept.

### Experiment 8: Computational Complexity
Exploration of algorithmic efficiency and complexity classes following the framework established by Cook (1971) in his groundbreaking work on NP-completeness.

## Theoretical Framework

### Historical Principles Underpinning the Research:

This research builds upon several fundamental principles in computational theory:

1. Church-Turing Thesis on computability
2. Information theory established by Claude Shannon
3. Complexity theory and NP-completeness
4. Cryptographic principles and security models

## Methodology

### Repository Access
```bash
git clone https://github.com/caolanmaguire/computational_theory.git
cd /computational_theory
```

### Research Environment Configuration
1. Implementation using [Anaconda](https://www.anaconda.com/products/distribution) for dependency management
2. Configuration of analytical packages for computational experiments

### Execution of Computational Experiments
1. Jupyter Notebook environment for code execution and analysis

## References

Arora, S., & Barak, B. (2009). *Computational Complexity: A Modern Approach*. Cambridge University Press.

Cook, S. A. (1971). The complexity of theorem-proving procedures. In *Proceedings of the Third Annual ACM Symposium on Theory of Computing* (pp. 151-158).

National Institute of Standards and Technology. (2015). *Secure Hash Standard (SHS)*. FIPS PUB 180-4.

Sipser, M. (2012). *Introduction to the Theory of Computation* (3rd ed.). Cengage Learning.

Turing, A. M. (1936). On computable numbers, with an application to the Entscheidungsproblem. *Proceedings of the London Mathematical Society*, 2(1), 230-265.

Weizenbaum, J. (1966). ELIZA—a computer program for the study of natural language communication between man and machine. *Communications of the ACM*, 9(1), 36-45.

## Acknowledgments

This research is conducted as part of the **Computational Theory** module at Atlantic Technological University (ATU).